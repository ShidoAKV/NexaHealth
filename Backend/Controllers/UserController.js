import validator from 'validator';
import bcrypt from 'bcrypt';
import { UserModel } from '../Models/UserModel.js';
import jwt from 'jsonwebtoken';
import { v2 as cloudinary } from 'cloudinary';
import { doctorModel } from '../Models/Doctormodel.js';
import { appointmentModel } from '../Models/AppointmentModel.js';
import razorpay from 'razorpay';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { FormModel } from '../Models/FormModel.js';
import moment from "moment";

/*
 Api for user to register,payment,profile change,login etc
*/

// Api to register user

const registerUser = async (req, res) => {

  try {
    const { name, email, password } = req.body;
    // console.log({name,password,email});

    if (!name || !email || !password) {
      return res.json({ success: false, message: 'Missing details' });
    }

    // validating email
    if (!validator.isEmail(email)) {
      return res.json({ success: false, message: 'Incorrect Email' });
    }

    // validating password
    if (password.length < 8) {
      return res.json({ success: false, message: 'Enter strong password' });
    }

    // hashing user password

    const salt = await bcrypt.genSalt(10);
    const hashedpassword = await bcrypt.hash(password, salt);

    const userdata = {
      name,
      email,
      password: hashedpassword,
    };

    const newUser = new UserModel(userdata);
    const user = await newUser.save();

    // creating token on basis of mongoDB _id generated by newUser ceation

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET);

    return res.status(200).json({ success: true, token });

  } catch (error) {
    console.log(error);
    return res.json({ success: "false", message: error.message });

  }
}

// Api to login
const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await UserModel.findOne({ email });

    if (!user) {
      return res.json({ success: false, message: 'User doesnot exist' });
    }

    const ismatched = await bcrypt.compare(password, user.password);

    if (ismatched) {
      const token = jwt.sign({ id: user._id, }, process.env.JWT_SECRET);
      return res.json({ success: true, token });
    } else {
      return res.json({ success: false, message: 'Invalid credentials' });
    }

  } catch (error) {
    console.log(error);
    return res.json({ success: false, message: error.message });
  }
}

// Api to get profile

const getProfile = async (req, res) => {
  try {

    const { userId } = req.body;

    const userdata = await UserModel.findById(userId).select('-password');
    //  console.log(userdata);

    return res.json({ success: true, userdata });


  } catch (error) {
    console.log(error);
    return res.json({ success: false, message: error.message });
  }
}

// Apito update user profile

const updateProfile = async (req, res) => {
  try {
    const { userId, name, phone, address, dob, gender } = req.body;
    const imageFile = req.file;

    if (!name || !phone || !address || !dob || !gender) {
      return res.json({ success: false, message: 'Data missing' });
    }

    let parsedAddress;
    try {
      parsedAddress = JSON.parse(address);
    } catch (error) {
      return res.json({ success: false, message: 'Invalid address format' });
    }

    await UserModel.findByIdAndUpdate(userId, {
      name,
      phone,
      dob,
      address: parsedAddress,
      gender,
    });

    if (imageFile) {
      const imageUpload = await cloudinary.uploader.upload(imageFile.path, {
        resource_type: 'image',
      });
      const imageURL = imageUpload.secure_url;
      await UserModel.findByIdAndUpdate(userId, { image: imageURL });
    }

    return res.json({ success: true, message: 'Profile Updated' });
  } catch (error) {
    console.error(error);
    return res.json({ success: false, message: error.message });
  }
};


// Api to book Appointment

const bookAppointment = async (req, res) => {
  try {
    const { userId, docId, slotDate, slotTime } = req.body;

    // Log input for debugging
    //  console.log('Request Body:', { userId, docId, slotDate, slotTime });

    // Validate input
    if (!docId || !userId || !slotDate || !slotTime) {
      return res.json({ success: false, message: 'All fields are required' });
    }

    // Fetch doctor data
    const docData = await doctorModel.findById(docId).select('-password');
    if (!docData) {
      return res.json({ success: false, message: 'Doctor not found' });
    }

    if (!docData.available) {
      return res.json({ success: false, message: 'Doctor is not available' });
    }

    // Initialize slots_booked if undefined
    let slots_booked = docData.slots_booked || {};

    // Check slot availability
    if (slots_booked[slotDate]) {
      if (slots_booked[slotDate].includes(slotTime)) {
        return res.json({ success: false, message: 'Slot is not available' });
      } else {
        slots_booked[slotDate].push(slotTime);
      }
    } else {
      slots_booked[slotDate] = [slotTime];
    }

    // Fetch user data
    const userData = await UserModel.findById(userId).select('-password');
    if (!userData) {
      return res.json({ success: false, message: 'User not found' });
    }

    // Prepare appointment data
    const appointmentdata = {
      userId,
      docId,
      userData,
      docData: { ...docData.toObject(), slots_booked: undefined }, // Avoid including `slots_booked`
      amount: docData.fees,
      slotTime,
      slotDate,
      date: Date.now()
    };

    // Save new appointment
    const newAppointment = new appointmentModel(appointmentdata);
    await newAppointment.save();

    // Update doctor's slots_booked
    await doctorModel.findByIdAndUpdate(docId, { slots_booked }, { new: true });

    return res.json({ success: true, message: 'Appointment booked successfully' });
  } catch (error) {
    console.error('Error booking appointment:', error);
    return res.json({ success: false, message: 'Error booking appointment: ' + error.message });
  }
};


//Api to get user Appointment for my-Appointment page

const listAppointment = async (req, res) => {

  try {
    const { userId } = req.body;

    const appointments =await appointmentModel.find({ userId });
  
    return res.json({ success: true, appointments });

  } catch (error) {

    return res.json({ success: false, message: error.message });
  }
}


// Api for cancelling the appointment From my-appointment-page

const cancelAppointment = async (req, res) => {

  try {
    const { userId, appointmentId } = req.body;

    const appointmentdata = await appointmentModel.findById(appointmentId);

    // verifying  appointment user

    if (appointmentdata.userId != userId) {
      return res.json({ success: false, message: 'Unauthorized Action' });
    }

    await appointmentModel.findByIdAndUpdate(appointmentId, { cancelled: true });


    // releasing doctor slots

    const { docId, slotTime, slotDate } = appointmentdata;

    const doctorData = await doctorModel.findById(docId);

    let slots_booked = doctorData.slots_booked;

    slots_booked[slotDate] = slots_booked[slotDate].filter(e => e !== slotTime);

    await doctorModel.findByIdAndUpdate(docId, { slots_booked });

    return res.json({ success: true, message: 'Appointment cancelled' });





  } catch (error) {
    console.error(error);
    return res.json({ success: false, message: error.message });
  }
}


const getuserprescriptionhistory = async (req, res) => {
    try { 
        const {email,patientName}=req.query;
        const data = await FormModel.find({email,patientName});
  
        return res.json({ success: true, message: data });
    } catch (error) {
        return res.json({ success: false, error });
    }
}


// Api for  notiification

const getNotification = async (req, res) => {
  try {
    const { userId } = req.params; 
    const today = moment().startOf("day").toDate();

    
    const appointments = await appointmentModel
      .find({
        userId,
        payment: true,
        cancelled: false,
        isCompleted: false,
        slotDate: { $exists: true },
      })
      .populate("docData")
      .lean();

    // Filter out only upcoming or today appointments
    const filteredAppointments = appointments.filter((appt) => {
      const appointmentDate = moment(appt.slotDate, "D_M_YYYY").startOf("day").toDate();
      return appointmentDate >= today;
    });

    // Sort by date ascending
    filteredAppointments.sort((a, b) => {
      const dateA = moment(a.slotDate, "D_M_YYYY").toDate();
      const dateB = moment(b.slotDate, "D_M_YYYY").toDate();
      return dateA - dateB;
    });

    if (filteredAppointments.length === 0) {
      return res.json({ success: false, message: "No upcoming notifications found" });
    }

    return res.json({ success: true, appointments: filteredAppointments });
  } catch (error) {
    console.error("Error fetching notifications:", error);
    return res.status(500).json({ success: false, message: "Server error", error });
  }
};

//Api to make payment of appointment using razorpay

const razorpayInstance = new razorpay(
  {
    key_id: process.env.RAZORPAY_KEY_ID,
    key_secret: process.env.RAZORPAY_SECRET
  }
);

const paymentRazorpay = async (req, res) => {
  try {

    const { appointmentId } = req.body;

    const appointmentData = await appointmentModel.findById(appointmentId);

    if (!appointmentData || appointmentData.cancelled) {
      return res.json({ success: false, message: 'Appointment cancelled or not found' });
    }

    // creating option for razorpay  payment

    const options = {
      amount: appointmentData.amount * 100,
      currency: process.env.CURRENCY,
      receipt: appointmentId
    };

    // creation of an order

    const order = await razorpayInstance.orders.create(options);

    if (!order || !order.id) {
      return res.json({ success: false, message: 'Order creation failed' });
    }
    // console.log(order,'Razorpay payment');


    return res.json({ success: true, order });

  } catch (error) {
    console.error(error);
    return res.json({ success: false, message: error.message });
  }
}


// Api to verify payment of razorpay

const verifyRazorpay = async (req, res) => {
  try {
    const { razorpay_order_id } = req.body;
    //  console.log(req.body);

    if (!razorpay_order_id) {
      return res.json({ success: false, message: 'Order ID is missing in response' });
    }

    // Fetch the order from Razorpay
    const orderInfo = await razorpayInstance.orders.fetch(razorpay_order_id);

    if (!orderInfo) {
      return res.json({ success: false, message: 'Order not found in Razorpay' });
    }

    // Check payment status
    if (orderInfo.status === 'paid') {
      await appointmentModel.findByIdAndUpdate(orderInfo.receipt, { payment: true });
      return res.json({ success: true, message: 'Payment Successful' });
    } else {
      return res.json({ success: false, message: 'Payment verification failed' });
    }

  } catch (error) {
    console.error(error);
    return res.json({ success: false, message: error.message });
  }
};

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

const AssistanceResponse = async (req, res) => {
  try {
    const { prompt, limit = 5 } = req.body;
      const rawText=prompt.trim();
   
     
    if (!rawText || typeof rawText !== 'string') {
      return res.json({
        success: false,
        message: 'Please send your query as text.',
      });
    } 

    const classifyPrompt = `
      You are an AI assistant. Classify the following user message into one of two categories:
      1. "general" — if it's a greeting, casual chat, or non-health related.
      2. "medical" — if it's a query about symptoms or health concerns.

      Return a JSON like: { "type": "general" } or { "type": "medical" }

      Message: "${rawText}"
      **Return only JSON.**
    `;

    const classifyRes = await model.generateContent(classifyPrompt);
    const classifyText = await classifyRes.response.text();

    const classification = JSON.parse(
      classifyText.replace(/```json/g, '').replace(/```/g, '')
    );
   


    if (classification.type === 'general') {
      const generalPrompt = `
        You are a friendly AI assistant. Respond conversationally to the user’s general message:
        
        "${rawText}"

        Keep it polite, casual, and helpful. No medical advice. Just plain chat.
        **Return only the message as plain text.**
      `;

      const generalRes = await model.generateContent(generalPrompt);
      const generalReply = await generalRes.response.text();

      
      return res.json({
        success: true,
        message: generalReply.trim(),
      });
    }

    const doctors = await doctorModel.find({}).limit(50).lean();

    if (!doctors.length) {
      return res.status(404).json({
        success: false,
        message: 'No doctors available.',
      });
    }

    const doctorProfiles = doctors.map((d) => ({
      name: d.name,
      specialty: d.speciality,
      about: d.about || '',
    }));

    const compositePrompt = `
      You are a clinical assistant.
      A patient wrote the following:

      "${rawText}"

      First, extract the patient's symptoms into a JSON array under the key "symptoms".
      Then, from the doctor list below, recommend the top ${limit} relevant doctors.
      Return a single JSON object with two keys:
        1. "symptoms": the array of detected symptoms
        2. "recommendations": an array of objects with:
            - name
            - specialty
            - reason (why they are a good match)

      Doctor list:
      ${JSON.stringify(doctorProfiles, null, 2)}

      **Return only valid JSON**
    `;

    const genResponse = await model.generateContent(compositePrompt);
    const genText = await genResponse.response.text();

    const cleanText = genText
      .replace(/```json/g, '')
      .replace(/```/g, '');

    if (!cleanText) {
      return res.status(502).json({
        success: false,
        message: 'Failed to parse Gemini response.',
      });
    }

    const parsed = JSON.parse(cleanText);
    const { symptoms, recommendations } = parsed;

    if (!symptoms || !symptoms.length) {
      return res.json({
        success: true,
        message: 'Sorry, no symptoms were detected.',
      });
    }

    return res.json({
      success: true,
      symptoms,
      recommendations,
    });
  } catch (error) {

    return res.json({
      success: false,
      message:error.message,
    });
  }
};


export {
  registerUser, loginUser, getProfile,
  updateProfile, bookAppointment, listAppointment,
  cancelAppointment, paymentRazorpay, verifyRazorpay, AssistanceResponse
  ,getuserprescriptionhistory,getNotification
};